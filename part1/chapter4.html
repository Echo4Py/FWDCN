<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="description" content="Flask Web Development" />
<meta name="keywords" content="Flask, Flask Web, Flask Web Development" />
<!--<meta name="robots" content="noindex,nofollow" />-->
<title>Chapter4</title>
<link type="text/css" rel="stylesheet" href="../css/forscreen.css" media="screen" />
<link rel="stylesheet" type="text/css" href="" media="print" />
<link rel="stylesheet" type="text/css" href="" media="handheld" />
</head>
<body>
<h1>Web表格</h1>
<p>
请求对象，在第二章介绍了，曝光了客户端发送的所有信息，发送的信息都带有一个请求。在细节上，request.form提供入口到在POST请求中提交的表格数据。
</p>
<p>
尽管在Flask的请求对象中所提供的支持对于web表格的处理是有意义的，这有一组任务数字变得单调乏味和重复。2个优良的示例是HTML代码产生给表格和提交表格数据的验证。
</p>
<p>
<a href="http://pythonhosted.org/Flask-WTF/" target=_blank>Flask-WTF</a>扩展与web表格一起工作是一个更令人高兴的经历。这个扩展是一个Flask集成包，围绕着框架不可知的<a href="http://wtforms.readthedocs.io/en/latest/" target=_blank>WTForms</a>包。
</p>
<p>
Flask-WTF和它自己的依赖能被用pip安装：
</p>
<textarea rows=3 cols=45 readonly="readonly" wrap="physical">
(venv) $ pip install flask-wtf
</textarea>
<fieldset id="f31">
<legend>交叉地点请求伪造（CSRF）保护</legend>
<p>
默认下，Flask-WTF保护所有表格防御Cross-Site Request Forgery交叉地点请求伪造（CSRF）攻击。当一个恶意网站发送请求到一个不同的受害者登录的网站上，一个CSRF攻击就会发生。
</p>
<p>
为了执行CSRF保护，Flask-WTF需要应用程序配置一个加密钥匙。Flask-WTF使用这个钥匙来产生加密过的token（语言符号），token被用来核实表单数据请求的真实性。示例4-1展示如何配置一个加密的钥匙。
</p>
<p>
示例4-1. hello.py：Flask-WTF配置<br />
<textarea rows=3 cols=45 readonly="readonly" wrap="physical">
app = Flask(__name__)
app.config['SECRET_KEY'] = 'hard to guess string'
</textarea>
</p>
<p>
这个app.config字典是一个普通目的的位置用来放置存储配置变量，配置变量被框架，扩展，或者应用程序本身使用。使用标准字典语法配置的值能被增加到app.config对象。配置对象也有方法来导入配置值，从文件中或者环境中导入。
</p>
<p>
这个SECRET_KEY配置变量被用作一个普通目的的加密钥匙，这个变量被Flask和一些第三方扩展使用。作为它名字的含义，加密的强度依赖于这个变量的值是机密的。在每一个应用程序中挑选一个不同机密的钥匙，这个机密钥匙是你建立并且确认这个字符串是不被任何人知道的。
</p>
<p>
<img src="../imgs/note.png" alt="a general note" />为了附加的安全，机密钥匙应该被存储在一个环境变量里，从而代替嵌入在代码里。这项技术在<a href="../part1/chapter7.html#">第七章</a>中被描述。
</p>
</fieldset>
<fieldset id="f32">
<legend>表格类</legend>
<p>
当使用Flask-WTF时，每一个web表格通过一个从Form类继承了的类表现出来。这个类定义了表单里的区域列表，每个被一个对象表现出来的。每个区域对象能有一个或多个验证者附着上；验证者是函数，这函数检查通过用户提交的输入是否合法。
</p>
<p>
示例4-2展示一个简单web表格，这个表格有一个文本区域和一个提交按钮。
</p>
<p>
示例4-2. hello.py：表格类定义<br />
<textarea rows=3 cols=45 readonly="readonly" wrap="physical">
from flask.ext.wtf import Form
from wtforms import StringField, SubmitField
from wtforms.validators import Required

class NameForm(Form):
    name = StringField('What is your name?', validators=[Required()])
    submit = Submitfield('Submit')
</textarea>
</p>
<p>
在表格中的区域被定义成类变量，并且每个类变量被分配给一个带有区域类型的对象。在前面示例中，NameForm表格有一个名叫name的文本区域以及一个叫做submit的提交按钮。StringField类表现了一个带有一个type="text"属性的&lt;input&gt;元素。SubmitField类表现了一个带有一个type="submit"属性的&lt;input&gt;元素。第一个针对区域构造器自变量是标签，这个标签在把表格翻译成HTML时被使用。
</p>
<p>
选项validators自变量包括在StringField构造器中，StringField构造器定义了一个检验器列表，这个检验器列表在被接收以前将被应用到被用户提交的数据中。Required()验证器保证了输入区域不会空着被提交。
</p>
<p>
<img src="../imgs/note.png" alt="a general note" />Form基础类被Flask-WTF扩展定义，所以Form是从flask.ext.wtf导入的。输入区域和验证器，不管怎么样都是从WTForms包裹中被直接导入的。
</p>
<p>
标准的HTML区域列表被WTForms支持着，这个列表展示在Table4-1中。
</p>
<table id="t4" class="tables">
<caption>Table4-1. WTForms标准HTML区域</caption>
<tr>
	<th>Field type</th>
	<th>Description</th>
</tr>
<tr>
	<td>StringField</td>
	<td>Text field</td>
</tr>
<tr>
	<td>TextAreaField</td>
	<td>Multiple-line text field</td>
</tr>
<tr>
	<td>PasswordField</td>
	<td>Password text field</td>
</tr>
<tr>
	<td>HiddenField</td>
	<td>Hidden text field</td>
</tr>
<tr>
	<td>DateField</td>
	<td>Text field that accepts a datetime.date value in a given format</td>
</tr>
<tr>
	<td>DateTimeField</td>
	<td>Text field that accepts a datetime.datetime value in a given format</td>
</tr>
<tr>
	<td>IntegerField</td>
	<td>Text field that accepts an integer value</td>
</tr>
<tr>
	<td>Decimalfield</td>
	<td>Text field that accepts a decimal.Decimal value</td>
</tr>
<tr>
	<td>FloatField</td>
	<td>Text field that accepts a floating-point value</td>
</tr>
<tr>
	<td>Booleanfield</td>
	<td>Checkbox with True and Fales values</td>
</tr>
<tr>
	<td>RadioField</td>
	<td>List of radio buttons</td>
</tr>
<tr>
	<td>SelectField</td>
	<td>Drop-down list of choices</td>
</tr>
<tr>
	<td>SelectMulitpleField</td>
	<td>Drop-down list of choices with multiple selection</td>
</tr>
<tr>
	<td>FileField</td>
	<td>File upload field</td>
</tr>
<tr>
	<td>SubmitField</td>
	<td>Form submission button</td>
</tr>
<tr>
	<td>FormField</td>
	<td>Embed a form as a field in a container form</td>
</tr>
<tr>
	<td>FieldList</td>
	<td>List of fields of a given type</td>
</tr>
</table>
<p>
WTForms内置验证器列表展示在Table4-2中。
</p>
<table id="t5" class="tables">
<caption>Table 4-2. WTForms验证器</caption>
<tr>
	<th>Validator</th>
	<th>Description</th>
</tr>
<tr>
	<td>Email</td>
	<td>Validates an email address</td>
</tr>
<tr>
	<td>EqualTo</td>
	<td>Compares the values of two fields;useful when requesting a password to be entered twice for confirmation</td>
</tr>
<tr>
	<td>IPAddress</td>
	<td>Validates an IPv4 network address</td>
</tr>
<tr>
	<td>Length</td>
	<td>Validates the length of the string entered</td>
</tr>
<tr>
	<td>NumberRange</td>
	<td>Validates that the value entered is within a numeric range</td>
</tr>
<tr>
	<td>Optional</td>
	<td>Allows empty input on the field, skipping additional validators</td>
</tr>
<tr>
	<td>Required</td>
	<td>Validates that the field contains data</td>
</tr>
<tr>
	<td>Regexp</td>
	<td>Validates the input against a regular expression</td>
</tr>
<tr>
	<td>URL</td>
	<td>Validates a URL</td>
</tr>
<tr>
	<td>AnyOf</td>
	<td>Validates that the input is one of a list of possible values</td>
</tr>
<tr>
	<td>NoneOf</td>
	<td>Validates that the input is none of a list of possible values</td>
</tr>
</table>
<p class="personal">
看到这里，自己对form和table有了一个理解，form在翻译中是表格的意思，但在实际表现出来中发现table更倾向于我们生活中制作的表格的样式。从form的内容中我发现更倾向于表单的一种功能，所以这里让我了解到表单与表格可以说是在一个范畴中的不同类型，表单更具备动态的特性，可以实现提交输入的数据，表格更倾向一种静态的展示效果，把数据以表格形式显示出来。
</p>
</fieldset>
<fieldset id="f33">
<legend>表格的HTML翻译</legend>
<p>
当被调用的时候，表格区域是可以随时支取的，从一个模板把表格区域翻译成HTML。假定方法函数把一个NameForm场合当成一个名叫form的自变量传递到模板，模板能生产出以下一个简单的HTML表格：
</p>
<textarea rows=3 cols=45 readonly="readonly" wrap="physical">
<form method="POST">
	{{ form.name.label }} {{ form.name() }}
	{{ form.submit() }}
</form>
</textarea>
<p>
当然，这个结果是非常缺少内容的。为了提高表格的可看程度，任何自变量发送到命令里，命令翻译的区域是被转化成HTML属性了；所以，例如，你可以给出区域id或者class属性，然后定义CSS样式：
</p>
<textarea rows=3 cols=45 readonly="readonly" wrap="physical">
<form method="POST">
	{{ form.name.label }} {{ form.name(id='my-text-field') }}
	{{ form.submit() }}
</form>
</textarea>
<p>
但甚至用HTML属性，这个用这样的方法所需要翻译成一个表格的努力是有意义的，所以对Bootstrap的自己表格样式组来说，这是最好的补充，无论什么时候都可以。Flask-Bootstrap提供一个非常高级别的助手函数翻译一整个Flask-WTF表格，使用Bootstrap的预先定义好的表格样式，所有这些都用一个单一命令。使用Flask-Bootstrap，前面表格能被翻译成下面的形式：
</p>
<textarea rows=3 cols=45 readonly="readonly" wrap="physical">
{{ import "bootstrap/wtf.html" as wtf %}
{{ wtf.quick_form(form) }}
</textarea>
<p>
import用同样的方式像规范的Python脚本那样直接工作，并且允许模板元素被导入和被用在很多模板里。导入bootstrap/wtf.html文件定义了助手函数用Bootstrap翻译Flask-WTF表格。wtf.quick_form()函数获得一个Flask-WTF表格对象并且用默认的Bootstrap样式来翻译它。提供给hello.py完整的模板被展示在示例4-3中。
</p>
<p>
示例4-3. templates/index.html：使用Flask-WTF和Flask-Bootstrap来翻译一个表格
</p>
<textarea rows=3 cols=45 readonly="readonly" wrap="physical">
{% extends "base.html" %}
{% import "bootstrap/wtf.html" as wtf %}

{% block title %}Flasky{% endblock %}

{% block page_content %}
<div class="page-header">
	<h1>Hello, {% if name %}{{ name }}{% else %}Stranger{% endif %}!</h1>
</div>
{{ wtf.quick_form(form) }}
{% endblock %}
</textarea>
<p>
模板的内容区域现在有了2个部分。第一个部分是一个显示一个问候的页面头。这有一个模板条件句被使用。在Jinja2里条件句有这样的格式{% if variable %}...{% else %}...{% endif %}。如果条件等于True，那么在if和else之间的内容直接显示出来，这个内容被翻译到模板。如果条件等于False，那么在else和endif之间的内容会被翻译到模板。例如当name模板自变量没被定义的时候模板将翻译字符串“Hello，Stranger！”。内容的第二部分使用wtf.quick_form()函数翻译NameForm对象。
</p>
</fieldset>
<fieldset id="f34">
<legend>在方法函数中表格处理</legend>
<p>
在新的hello.py版本中，index()方法函数将进行表格翻译，也同样接受表格数据。示例4-4展示升级后的index()方法函数。
</p>
<p>
示例4-4. hello.py：路线方法
</p>
<textarea rows=3 cols=45 readonly="readonly" wrap="physical">
@app.route('/', methods=['GET', 'POST'])
def index():
	name = None
	form = NameForm()
	if form.validate_on_submit():
		name = form.name.data
		form.name.data = ''
	return render_template('index.html', form=form, name=name)
</textarea>
<p>
methods自变量增加到app.route装饰器告诉了Flask要去注册方法函数成为一个在URL map里为GET和POST请求的处理器。当methods没有被给出的时候，方法函数只被注册为GET请求处理器。
</p>
<p>
增加POST到方法列表中是需要的，因为表格提交是更方便的被处理为POST请求。作为一个GET请求提交一个表格是可能的，但作为很多GET请求是没有主体的，数据作为一个问号字符串被追加到URL上并且变成在浏览器地址栏中是可以看得见的。因为这个和其它一些原因，表格提交大多数普遍地作为POST请求来工作。
</p>
<p>
当表格中的名字是可变的时候，本地name变量被用来保存从表格收到的名字；当名字不被知道时，变量被初始化成None。方法函数建立一个前面展示的NameForm类场合到现在的表格。当表格被提交以及被所有区域验证器接收数据时，表格的validate_on_submit()方法返回True。在所有其它案例中，validate_on_submit()返回False。这种有效地服务方法的返回值决定表格是否需要被翻译或者被处理。
</p>
<p>
当一个用户第一次航行到应用程序时，服务器将收到一个没有表格数据的GET请求，所以validate_on_submit()将返回False。if表达式的主体将被跳过并且请求将通过翻译模板被处理，获得哪种表格对象并且name变量设置成None作为自变量。用户现在将看到表格显示在浏览器中。
</p>
<p>
当表格被用户提交时，服务器收到一个带有数据的POST请求。命令到validate_on_submit()处理附加名字区域的Required()验证器。如果名字不是空的，那么验证器接收它并且validate_on_submit()返回True。现在通过用户输入的名字是可得到作为区域的数据属性。在if表达式的主体里面，这个名字被分配到本地name变量并且表单区域被清空，这个被清空是通过设置data属性为一个空的字符串实现的。在最后一行里render_template()命令翻译了模板，但这个时候name自变量包含了从表单来的名字，所以问候将被个人化。
</p>
<p>
<img src="../imgs/tip.png" alt="a tip or suggestion" />如果你已经在GitHub上克隆了应用程序的Git容器，你可以运行git checkout 4a来检查这个版本的应用程序。
</p>
<p>
图表4-1展示了当一个用户初始化进入这个网站的时候，在浏览器窗口里表单看起来如何。当用户提交一个名字的时候，应用程序响应了一个个人化的问候。表格仍显示在下面，所以一个用户如果渴望的话可以提交一个新名字。图表4-2显示了在这个状态中的应用程序。
</p>
<p>
图表4-1. Flask-WTF网络表单<br />
<img src="../imgs/figure41.png" alt="snapshot" />
</p>
<p>
如果用户提交一个空名字表单，Required()验证器捕获错误，像在图表4-3中看到样子。注意被自动地提供是多么功能化。这是一个有力量的很好示例，设计地很好的扩展像Flask-WTF以及Flask-Bootstrap能提供给你的应用程序。
</p>
<p>
图表4-2. 提交后的web表单<br />
<img src="../imgs/figure42.png" alt="snapshot" />
</p>
<p>
图表4-3. 验证失败后的web表单<br />
<img src="../imgs/figure43.png" alt="snapshot" />
</p>
</fieldset>
<fieldset id="f35">
<legend>重定向和用户会议</legend>
<p>
最近的hello.py版本有一个可用性问题。如果你输入你的名字并且提交名字，然后在你的浏览器上单击刷新按钮，你将得到一个难以解释的警告，警告在提交表单之前再次请求确认。这个发生是因为浏览器重复它们已经发送的最近的请求，当它们被问到刷新页面时。当最近的一个带有表单数据的POST请求发送的时候，一个刷新会导致一个副本表单提交，在大多数原因中不是想得到的动作。
</p>
<p>
很多用户不理解从浏览器来的警告。因为这个原因，为了web应用程序从来不离开一个POST请求作为一个最近被浏览器发送的请求，好的实行被考虑到了。
</p>
<p>
这个实行通过用一个重定向POST请求响应替代一个普通响应能达到。一个重定向是一个响应的特殊类型，这个响应有一个URL来代替一个HTML代码的字符串。当浏览器接收这个响应时，浏览器为重定向URL发出一个GET请求，并且那就是所显示的页面。页面也许花费一些更多的毫秒来加载，因为第二个请求已经被发送到服务器，但除此之外，用户不会看到任何不同。现在最近的请求是一个GET，所以刷新命令如期工作。这个诀窍作为Post/Redirect/Get模式被知晓。
</p>
<p>
但这个方法带来第二个问题。当应用程序处理POST请求时，程序有在form.name.data中被用户输入名字的入口，但与此同时请求结束表单数据会丢失。因为POST请求用一个重定向来处理，应用程序需要存储名字，所以重定向请求能拥有名字并使用名字来建立实际响应。
</p>
<p>
应用程序能记住从一个请求到下一个请求来的事情，通过存储它们到用户会议里，私有存储是可以被每一个连接的客户端使用的。用户会议在<a href="../part1/chapter2.html#associated">第二章</a>里被介绍，作为与请求内容有关联的变量中的一种。它叫做session并且是可以被存取的，像一个标准Python字典一样。
</p>
<p>
<img src="../imgs/note.png" alt="a general note" />默认情况下，用户会议被存储在客户端cookies里，客户端的cookies是加密地、已签名的、使用SECRET_KEY配置过的。任何篡改cookie内容将翻译成无效签名，从而把会议遣送回家。
</p>
<p>
示例4-5展示一个index()方法函数的新版本，这个版本执行重定向和用户会议。
</p>
<p>
示例4-5. hello.py：重定向与用户会议
</p>
<textarea rows=3 cols=45 readonly="readonly" wrap="physical">
from flask import Flask, render_template, session, redirect, url_for

@app.route('/', methods=['GET', 'POST'])
def index():
	form = NameForm()
	if form.validate_on_submit():
		session['name'] = form.name.data
		return redirect(url_for('index'))
	return render_template('index.html'), form = form, name=session.get('name'))
</textarea>
<p>
在先前应用程序那个版本中，一个本地name变量被用来存储被用户送入的表单中的名字。那个变量现在被放进用户会议里作为session['name']，于是变量跨过请求被记住了。
</p>
<p class="personal">
这里我明白了即使没有请求的时候，名字也被存储在变量里。换句话说，如果没有使用session技术，那么名字只有在发送请求时才能被使用，就像在前面章节中把名字写在地址栏里才能实现个性化问候效果一样。用了session技术后，只要你在表单中填写了内容的话，并且按下提交，那么名字就会被存储下来，所以即使刷新页面也一样不影响其结果。
</p>
<p>
伴随着合法表单数据发生的请求现在将伴随着一个redirect()命令结束，一个助手函数生产了HTTP重定向响应。redirect()函数得到URL作为一个自变量来达到重定向。在这个案例中被使用的重定向URL是根URL，所以响应将被更简明地写成redirect('/')，但反而Flask的URL发生器函数url_for()被使用了。url_for()的用法是为了生产URL，这样的用法被鼓励，因为这个函数用URL map生产了URL，所以当使用这个函数时，URL能自动有效的与定义路线和任何对路线名字产生的变化保持一致。
</p>
<p class="personal">
session技术是实现URL与路线有关信息变化保持自动化一致的核心技术。这样避免无法找到正确的响应页面。session技术中cookie是存储数据的地方，所以cookie也成了自动化的另外一个众矢之的。
</p>
<p>
对url_for()来说，第一个自变量而且只需要的自变量是endpoint名字，每个路线所有的内部名字。默认情况下，一个路线的端点是方法函数的名字。在这个示例中，方法函数处理的根URL是index()，所以提供给url_for()的名字是index。
</p>
<p>
最后的变化是在render_tempalte()函数中，在函数中从使用session.get('name')会议直接获得name自变量。作为使用正规的字典，使用get()达到要求一个字典键避免了一个不存在的键例外情况发生，因为get()为一个不存在的键返回一个None的默认值。
</p>
<p>
<img src="../imgs/tip.png" alt="a tip or suggestion" />如果你已经在GitHub上克隆了应用程序的Git容器，你可以运行git checkout 4b来检查应用程序的这个版本。
</p>
<p>
用应用程序的这个版本，你可以看见在你的浏览器中刷新页面得到期望表现的结果。
</p>
</fieldset>
<fieldset id="36">
<legend>消息闪烁</legend>
<p>
在一个请求完成之后给用户一个状态更新有时是有用的。这可以是一个确认消息，一个警告，或者一个错误。一个典型示例是，当你提交一个带有一个错误的登录表单给一个网站时，并带有一个上面通知你的用户名或者密码错误消息通过再次翻译登录表单的服务器响应时。
</p>
<p class="personal">
我发现登录界面其实是属于表单范畴的事物。
</p>
<p>
Flask包含这个功能作为一个核心特性。示例4-6展示flash()函数为达到这个目的如何被使用的。
</p>
<p>
示例4-6. hello.py：闪烁的消息
</p>
<textarea rows=3 cols=45 readonly="readonly" wrap="physical">
from flask import Flask, render_template, session, redirect, url_for, flash

@app.route('/', methods=['GET', 'POST']
def index():
	form = NameForm()
	if form.validate_on_submit():
		old_name = session.get('name')
		if old_name is not None and old_name != form.name.data:
			flash('Looks like you have changed your name!')
		session['name'] = form.name.data
		form.name.data = ''
		return redirect(url_for('index'))
	return render_template('index.html', form = form, name = session.get('name'))
</textarea>
<p>
在这个示例中，每次一个被提交的名字要与存储在用户会议中的名字进行比较，在一个前面相同表单的提交期间是否被放到那里？如果这两个名字不一样，flash()函数随着一个被显示在下一次发回到客户端的响应消息一起被调用。
</p>
<p>
调用flash()不足以达到获得显示出来的消息；通过应用程序模板被使用需要翻译这些消息。最好的地方来翻译闪烁的消息是基础模板，因为这些消息将用在所有的页面中。Flask制作了一个get_flashed_messages()函数，可以被用在模板到恢复这些消息和翻译它们，就像在示例4-7中展示的那样。
</p>
<p>
示例4-7. templates/bashe.html：闪烁消息翻译
</p>
<textarea rows=3 cols=45 readonly="readonly" wrap="physical">
{% block content %}
<div class="container">
	{% for message in get_flashed_messages() %}
	<div class="alert alert-warning">
		<button type="button" class="close" data-dismiss="alert>%times;</button>
		{{ message }}
	</div>
	{% endfor %}
	
	{% block page_content %}{% endblock %}
</div>
{% endblock %}
</textarea>
<p>
在这个示例中，消息是使用为了警告消息设计的Bootstrap的警告CSS样式翻译过的（一种被展示在图示4-4中）。
</p>
<p>
图示4-4. 闪烁的消息<br />
<img src="../imgs/figure44.png" alt="snapshot" />
</p>
<p>
一个循环被使用，是因为那里可能有很多消息列队来显示，一种是在先前的请求循环中为了每次flash()被调用。从get_flashed_messages()被恢复的消息不会被返回到这个函数下次被调用，所以闪烁的消息只显示一次后就被丢弃。
</p>
<p>
<img src="../imgs/tip.png" alt="a tip or suggestion" />如果你已经在GitHub上克隆了应用程序的Git容器，你可以运行git checkout 4c来检查应用的这个版本。
</p>
<p>
能够从用户通过web表单接收数据对于大多数应用程序是一个需要的特性，同时在持续存储中也是存储那个数据的能力。用Flask使用数据库是下一章的话题。
</p>
</fieldset>

</body>
</html>
